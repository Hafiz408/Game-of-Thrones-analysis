# -*- coding: utf-8 -*-
"""GameOfThrones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l5o3e23-KWxkX38tLdPF8Y3vL1LFp0i1

# Brief

Team:

*   Ashish - 19PD06
*   Maadhav - 19PD21
*   Hafiz - 19PD22
*   Sai Krishna - 19PD29

Here, we are trying to predict the character death and battle outcome of the famous 'Game of Thrones' series using various regression models.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import warnings 
from sklearn.preprocessing import LabelEncoder
warnings.filterwarnings('ignore')
import sklearn
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression

import sklearn
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn import svm
from sklearn import tree
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report
from sklearn.metrics import roc_auc_score
from sklearn.metrics import accuracy_score
from sklearn.metrics import log_loss

character_deaths=pd.read_csv('https://raw.githubusercontent.com/ArachnidAgrajag/got-analysis-18xd43/main/character-deaths.csv')
battle=pd.read_csv('https://raw.githubusercontent.com/ArachnidAgrajag/got-analysis-18xd43/main/battles.csv')
character_predictions=pd.read_csv('https://raw.githubusercontent.com/ArachnidAgrajag/got-analysis-18xd43/main/character-predictions.csv')

"""# EDA"""

battle.head(5)

character_deaths.head()

character_predictions.head()

battle.info()

battle.describe()

battle.isnull().sum()

"""# Data cleansing

## Handling anomaly
"""

for i in battle[battle['defender_king']=='Joffrey/Tommen Baratheon'].index:
  battle.loc[i,'defender_king']='Joffrey/Tommen Lannister'

for i in battle[battle['attacker_king']=='Joffrey/Tommen Baratheon'].index:
  battle.loc[i,'attacker_king']='Joffrey/Tommen Lannister'

"""## Removing the wars with no attacker king

"""

battle.dropna(subset=['attacker_king'],axis=0,inplace=True)
battle.dropna(subset=['defender_king'],axis=0,inplace=True)

"""## Finding the House name of attacker and defender kings"""

for i in battle.index:
  battle.loc[i,'Attacker_House']=battle.loc[i,'attacker_king'].split(' ')[-1]
  battle.loc[i,'Defender_House']=battle.loc[i,'defender_king'].split(' ')[-1]

for i in battle.index:
  if battle.loc[i,'attacker_outcome']=='win':
    battle.loc[i,'Attack Victory']=1
  else:
    battle.loc[i,'Attack Victory']=0

for i in battle.index:
  if battle.loc[i,'attacker_outcome']=='win':
    battle.loc[i,'Defense Victory']=0
  else:
    battle.loc[i,'Defense Victory']=1

for i in battle.index:
  for j in battle['battle_type'].unique():
    if battle.loc[i,'battle_type']==j:
      battle.loc[i,j]=1
    else:
      battle.loc[i,j]=0

battle

battle['Defender_House'].value_counts()

"""# House wise data handling

## Battle data segregation
"""

df=pd.DataFrame()

Wars_Waged=battle.groupby('Attacker_House')['Attack Victory'].count()
Win_Ratio=battle.groupby('Attacker_House')['Attack Victory'].sum()
Wars_Defended=battle.groupby('Defender_House')['Defense Victory'].count()
Defense_Win_Ratio=battle.groupby('Defender_House')['Defense Victory'].sum()
#sum values used after this
#attacker side
Seige=battle.groupby('Attacker_House')['siege'].sum()
Razing=battle.groupby('Attacker_House')['razing'].sum()
Pitched_battle=battle.groupby('Attacker_House')['pitched battle'].sum()
Ambush=battle.groupby('Attacker_House')['ambush'].sum()
Seige_Win=battle.query("`Attack Victory`==1").groupby('Attacker_House')['siege'].sum()
Razing_Win=battle.query("`Attack Victory`==1").groupby('Attacker_House')['razing'].sum()
Pitched_battle_win=battle.query("`Attack Victory`==1").groupby('Attacker_House')['pitched battle'].sum()
Ambush_win=battle.query("`Attack Victory`==1").groupby('Attacker_House')['ambush'].sum()
#defender side
Seige2=battle.groupby('Defender_House')['siege'].sum()
Razing2=battle.groupby('Defender_House')['razing'].sum()
Pitched_battle2=battle.groupby('Defender_House')['pitched battle'].sum()
Ambush2=battle.groupby('Defender_House')['ambush'].sum()
Seige_Win2=battle.query("`Attack Victory`==0").groupby('Defender_House')['siege'].sum()
Razing_Win2=battle.query("`Attack Victory`==0").groupby('Defender_House')['razing'].sum()
Pitched_battle_win2=battle.query("`Attack Victory`==0").groupby('Defender_House')['pitched battle'].sum()
Ambush_win2=battle.query("`Attack Victory`==0").groupby('Defender_House')['ambush'].sum()

df=pd.DataFrame({'Wars Waged':Wars_Waged,'Attack Win count':Win_Ratio,'Attacker siege':Seige,'Attacker siege win':Seige_Win,'Attacker razing':Razing,'Attacker razing win':Razing_Win,'Attacker Pitched Battle':Pitched_battle,'Attacker Pitched battle win':Pitched_battle_win,'Attacker Ambush':Ambush,'Attacker ambush win':Ambush_win,'Wars Defended':Wars_Defended,'Defense Win count':Defense_Win_Ratio,'Defender seige':Seige2,'Defender seige win':Seige_Win2,'Defender razing':Razing2,'Defender razing win':Razing_Win2,'Defender Pitched Battle':Pitched_battle_win2,'Defender Pitched battle win':Pitched_battle_win2,'Defender Ambush':Ambush2,'Defender ambush win':Ambush_win2})
df.columns=df.columns.str.replace('index','House')
df.fillna(0,axis=0,inplace=True)
df.head()

attacker_house=battle['Attacker_House'].unique()
attacker_house

"""## Alliances formed between houses calculation"""

alliance={}
for x in attacker_house:
  a=battle[(battle['Attacker_House']==x) & (battle['attacker_1']!=x)]
  l=a['attacker_1'].tolist() + a['attacker_2'].tolist() + a['attacker_3'].tolist() + a['attacker_4'].tolist()
  l=[x for x in l if str(x) != 'nan']
  alliance[x]=l
alliance

defender_house=battle['Defender_House'].unique()
defender_house

alliance2={}
for x in defender_house:
  a=battle[(battle['Defender_House']==x) & (battle['defender_1']!=x)]
  l=a['defender_1'].tolist() + a['defender_2'].tolist() + a['defender_3'].tolist() + a['defender_4'].tolist()
  l=[x for x in l if str(x) != 'nan']
  alliance2[x]=l
alliance2

key1=alliance.keys()
key2=alliance2.keys()
for x in key2:
  if x in key1:
    s=alliance.get(x)
    s2=alliance2.get(x)
    for i in s:
      s2.append(i)
      alliance2[x]=s2
alliance2

all_houses=[]
for x in alliance.keys():
  for l in alliance[x]:
    all_houses.append(l)

for x in alliance2.keys():
  for l in alliance2[x]:
    all_houses.append(l)
all_houses=list(set(all_houses))

all_houses

len(all_houses)

for x in alliance2.keys():
  for y in all_houses:
    # a=battle[(battle['Attacker_House']==x) & (battle['attacker_1']!=x) & (battle['attacker_1']==y) | (battle['attacker_2']==y) | (battle['attacker_3']==y) | (battle['attacker_4']==y) | (battle['defender_1']==y) | (battle['defender_2']==y) | (battle['defender_3']==y) | (battle['defender_4']==y)]
    df.loc[x,y]=alliance2[x].count(y)
df=df.fillna(0)
df['Lannister','Lannister']=0

df

df['victory']=(df['Attack Win count']+df['Defense Win count'])/(df['Wars Waged']+df['Wars Defended'])

"""## House stats visualisation"""

plt.figure(figsize=(15,7))
plt.plot(df['Wars Waged'],label='Wars waged',marker='o',markersize='10')
plt.plot(df['Attack Win count'],label='Attack won',marker='*',linestyle='-.',markersize='15')
plt.plot(df['Wars Defended'],label='Wars defended',marker='D',markersize='10')
plt.plot(df['Defense Win count'],label='Defense won',marker='^',linestyle='-.',markersize='10')
plt.xlabel('House name')
plt.title('House War Stats')
plt.legend()

plt.figure(figsize=(15,7))
plt.plot(df['Attacker siege'],label='Siege',marker='o',markersize='10',)
plt.plot(df['Attacker siege win'],label='Siege won',marker='*',linestyle='-.',markersize='15')
plt.plot(df['Attacker razing'],label='Razing',marker='o',markersize='10')
plt.plot(df['Attacker razing win'],label='Razing won',marker='*',linestyle='-.',markersize='15')
plt.plot(df['Attacker Pitched Battle'],label='Pitched battle',marker='o',markersize='10')
plt.plot(df['Attacker Pitched battle win'],label='Pitched battle won',marker='*',linestyle='-.',markersize='15')
plt.plot(df['Attacker Ambush'],label='Ambush',marker='o',markersize='10')
plt.plot(df['Attacker ambush win'],label='Ambush won',marker='*',linestyle='-.',markersize='15')
plt.xlabel('House name')
plt.title('Attack type Stats')
plt.legend()

plt.figure(figsize=(15,7))
plt.plot(df['Defender seige'],label='Siege',marker='o',markersize='10',)
plt.plot(df['Defender seige win'],label='Siege won',marker='*',linestyle='-.',markersize='15')
plt.plot(df['Defender razing'],label='Razing',marker='o',markersize='10')
plt.plot(df['Defender razing win'],label='Razing won',marker='*',linestyle='-.',markersize='15')
plt.plot(df['Defender Pitched Battle'],label='Pitched battle',marker='o',markersize='10')
plt.plot(df['Defender Pitched battle win'],label='Pitched battle won',marker='*',linestyle='-.',markersize='15')
plt.plot(df['Defender Ambush'],label='Ambush',marker='o',markersize='10')
plt.plot(df['Defender ambush win'],label='Ambush won',marker='*',linestyle='-.',markersize='15')
plt.xlabel('House name')
plt.title('Defend against type Stats')
plt.legend()

df[all_houses].plot(kind='bar',figsize=(20,10))

width=0.35

plt.legend((p1[0], p2[0]), ('Attack won', 'Wars Waged'))

width=0.35
s1=plt.bar(df.index, df['Defense Win count'], width)
s2=plt.bar(df.index, df['Wars Defended'], width,bottom=df['Defense Win count'])
plt.xlabel('House Names')
plt.title('Defendinging Stats')
plt.legend((s1[0], s2[0]), ('Defend won', 'Wars Defended'))

hd={'Wildling':1,'None': 2,'Night\'s Watch':3,'Lannister':4,'House Lannister':4,'Stark':5,'House Stark':5,
			'Tully':6,'House Tully':6, 'Arryn':7,'House Arryn':7,'Tyrell':8, 'House Tyrell':8, 'Targaryen':9,
			'House Targaryen':9,'Martell':10,'House Martell':10,'Baratheon':11,'House Baratheon':11,'Greyjoy':12,'House Greyjoy':12}

"""# Battle victory prediction"""

battle.head()

battle_train=pd.read_csv('https://raw.githubusercontent.com/ArachnidAgrajag/got-analysis-18xd43/main/battles.csv')

battle_train.info()

battle_train.describe()

battle_train.shape

battle_train.isnull().sum()

"""## Handling missing data """

battle_train['attacker_size'].fillna((battle_train['attacker_size'].mean()),inplace=True)
battle_train['defender_size'].fillna((battle_train['defender_size'].mean()),inplace=True)
battle_train['summer'].fillna(battle_train['summer'].mode(),inplace=True)
battle_train.fillna('None',inplace=True)

battle_train.head(50)

battle_train.columns

for i in battle_train.index:
  if battle_train.loc[i,'attacker_outcome']=='win':
    battle_train.loc[i,'Attack Victory']=1
  else:
    battle_train.loc[i,'Attack Victory']=0

"""## Visuals"""

corr=battle_train.corr()
sns.heatmap(corr)

sns.distplot(battle_train['attacker_size'])

sns.distplot(battle_train['defender_size'])

"""## Fitting and testing the model"""

drop1=['defender_2','defender_3','defender_4','note','attacker_3','attacker_4','attacker_outcome']
battle_train.drop(drop1,axis=1,inplace=True)

battle_train.columns

battle_train.drop(25,inplace=True)

battle_train=pd.get_dummies(battle_train)

y2=battle_train['Attack Victory']
X2=battle_train.drop('Attack Victory',axis=1)

X2.head()

lr=LogisticRegression()
X2_train,X2_test,y2_train,y2_test=train_test_split(X2,y2,test_size=0.33,random_state=42)
lr.fit(X2_train,y2_train)
lr.score(X2_test,y2_test)

y2_pred=lr.predict(X2_test)
y2_test=np.array(y2_test)

confusion_matrix(y2_test,y2_pred)

"""## Predicting for user input data"""

red_wedding=battle_train.iloc[25]
red_wedding

battle_train=pd.get_dummies(battle_train)

red_wedding=battle_train.iloc[25]
battle_train.drop(25,inplace=True)

y2=battle_train['Attack Victory']
X2=battle_train.drop('Attack Victory',axis=1)
lr=LogisticRegression()
X2_train,X2_test,y2_train,y2_test=train_test_split(X2,y2,test_size=0.33,random_state=42)
lr.fit(X2_train,y2_train)
lr.score(X2_test,y2_test)

red_wedding['Attack Victory']

red_wedding=red_wedding.drop('Attack Victory')

result=lr.predict_proba([red_wedding.T])
result

if result[0,1]>0.5 :
  print('Battle Won')
else:
  print('Battle Lost')

"""# CHARACTER DEATH PREDICTION

## Descriptive Stats
"""

character_predictions.head(10)

character_predictions.shape

character_predictions.info()

character_predictions.describe()

character_predictions.drop(['actual','pred','alive','plod'],axis=1,inplace=True)

character_predictions.isnull().sum()

character_predictions.nunique()

"""## EDA"""

character_predictions['title'].fillna('No Title',inplace=True)

"""### Handling House Null values


"""

character_predictions['house'].fillna('',inplace=True)
for i in character_predictions.index:
  if character_predictions.loc[i,'house'].split(' ')[0]=='House':
    character_predictions.loc[i,'house']=character_predictions.loc[i,'house'].split(' ')[-1]

character_predictions[['name','house']].head(50)

house_names_list=list(character_predictions['house'].unique())
print(house_names_list)

for i in character_predictions.index:
  if character_predictions.loc[i,'name'].split(' ')[-1] in house_names_list and character_predictions.loc[i,'house']=='':
    character_predictions.loc[i,'house']=character_predictions.loc[i,'name'].split(' ')[-1]
  elif character_predictions.loc[i,'house']=='':
    character_predictions.loc[i,'house']='No house'

character_predictions.info()

"""### Handling Culture Null Values"""

character_predictions['culture'].fillna('None',inplace=True)

character_predictions['culture'].unique()

cult = {
    'Summer Islands': ['summer islands', 'summer islander', 'summer isles'],
    'Ghiscari': ['ghiscari', 'ghiscaricari',  'ghis'],
    'Asshai': ["asshai'i", 'asshai'],
    'Lysene': ['lysene', 'lyseni'],
    'Andal': ['andal', 'andals'],
    'Braavosi': ['braavosi', 'braavos'],
    'Dornish': ['dornishmen', 'dorne', 'dornish'],
    'Myrish': ['myr', 'myrish', 'myrmen'],
    'Westermen': ['westermen', 'westerman', 'westerlands'],
    'Westerosi': ['westeros', 'westerosi'],
    'Stormlander': ['stormlands', 'stormlander'],
    'Norvoshi': ['norvos', 'norvoshi'],
    'Northmen': ['the north', 'northmen'],
    'Free Folk': ['wildling', 'first men', 'free folk'],
    'Qartheen': ['qartheen', 'qarth'],
    'Reach': ['the reach', 'reach', 'reachmen'],
    'Ironborn': ['ironborn', 'ironmen'],
    'Mereen': ['meereen', 'meereenese'],
    'RiverLands': ['riverlands', 'rivermen'],
    'Vale': ['vale', 'valemen', 'vale mountain clans'],
    'Astapori':['astapor','astapori']
}

def get_cult(value):
  value=value.lower()
  v=[k for (k,v) in cult.items() if value in v]
  return v[0] if len(v)>0 else value.title()
  
character_predictions.loc[:,'culture']=[get_cult(x) for x in character_predictions['culture']]

character_predictions['culture'].unique()

df=character_predictions[character_predictions['culture']!='None']
house_culture_group=df.groupby('house')['culture'].agg(lambda x: pd.Series.mode(x)[0])
house_culture_group=dict(house_culture_group)
house_culture_group

for i in character_predictions.index:
  if character_predictions.loc[i,'house']!='No House' and character_predictions.loc[i,'house'] in house_culture_group.keys():
    character_predictions.loc[i,'culture']=house_culture_group[character_predictions.loc[i,'house']]

"""### Handling the null values of numerical data and some inconsistent data"""

character_predictions[character_predictions['age']<0]

character_predictions.loc[1684,'age']=25
character_predictions.loc[1868,'age']=0

character_predictions['age'].fillna(character_predictions['age'].mean(),inplace=True)

character_predictions[character_predictions['dateOfBirth']<0]

character_predictions.loc[87,'dateOfBirth']=259

character_predictions[character_predictions['dateOfBirth']>300]

character_predictions.info()

character_predictions.loc[1684,'dateOfBirth']=character_predictions.loc[1868,'DateoFdeath']-25
character_predictions.loc[1868,'dateOfBirth']=character_predictions.loc[1868,'DateoFdeath']=233

character_predictions.isnull().sum()

character_predictions['dateOfBirth'].fillna(np.round(character_predictions['dateOfBirth'].mean()),inplace=True)

character_predictions.head(5)

character_predictions['isAliveSpouse'].fillna(2,inplace=True)

character_predictions['isAliveMother'].fillna(2,inplace=True)
character_predictions['isAliveFather'].fillna(2,inplace=True)
character_predictions['isAliveHeir'].fillna(2,inplace=True)

"""### Importing Modules

### Drop the unnecessary columns
"""

drop_columns=['S.No','name','DateoFdeath','mother','father','heir','spouse']
data=character_predictions.drop(drop_columns,axis=1)
data.info()

"""### Encoding the Object type data using Label Encoding"""

LE=LabelEncoder()
data['culture']=LE.fit_transform(data['culture'])
data['title']=LE.fit_transform(data['title'])
data['house']=LE.fit_transform(data['house'])

data.head(10)

"""### Graphs and Plots"""

f, ax = plt.subplots(1, 2, figsize = (15, 7))
f.suptitle("Class Distribution", fontsize = 18.)
_ = data['isAlive'].value_counts().plot.bar(ax = ax[0], rot = 0,color={'green','blue'}).set(xticklabels = ["Alive", "Deceased"])
_ = data['isAlive'].value_counts().plot.pie(labels = ("Alive", "Deceased"), autopct = "%.2f%%", label = "", fontsize = 13., ax = ax[1],colors = (sns.color_palette()[0], sns.color_palette()[2]), wedgeprops = {"linewidth": 1.5, "edgecolor": "white"}), ax[1].texts[1].set_color("white"), ax[1].texts[3].set_color("white")

plt.figure(figsize=(20,15))
corr=data.corr()
sns.heatmap(corr,annot=True)

data.isnull().sum()

sns.distplot(data['dateOfBirth'])

sns.displot(data['age'],kde=True)

data_x= character_predictions.groupby(["culture", "isAlive"]).count()["S.No"].unstack()
data_x.loc[:, "total"]= data_x.sum(axis = 1)
p = data_x[data_x.index != ""].sort_values("total")[[0, 1]].plot.barh(stacked = True, rot = 0, figsize = (14, 12),)
p_= p.set(xlabel = "No. of Characters", ylabel = "Culture"), p.legend(["Dead", "Alive"], loc = "lower right",fontsize=12)
plt.title('Culture and Character Death relation',fontdict={'fontsize': '15'})

"""### Splitting the data to train and test Data"""

X=data.drop('isAlive',axis=1)
y=data['isAlive']
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.33,random_state=42)

"""# Logistic Regression Model"""

model = LogisticRegression()
solvers = ['newton-cg', 'lbfgs', 'liblinear']
penalty = ['l2']
c_values = [100, 10, 1.0, 0.1, 0.01]
grid = dict(solver=solvers,penalty=penalty,C=c_values)
grid_search = GridSearchCV(estimator=model, param_grid=grid, n_jobs=-1, cv=5, scoring='accuracy',error_score=0)
grid_result = grid_search.fit(X, y)
print("Best: %f using %s" % (grid_result.best_score_, grid_result.best_params_))
means = grid_result.cv_results_['mean_test_score']
stds = grid_result.cv_results_['std_test_score']
params = grid_result.cv_results_['params']
for mean, stdev, param in zip(means, stds, params):
    print("%f (%f) with: %r" % (mean, stdev, param))

lr=LogisticRegression(C=0.01,penalty='l2',solver='newton-cg')
lr.fit(X_train,y_train)
print(np.mean(cross_val_score(lr,X,y)))

df = pd.DataFrame(list(zip(X_train.columns, lr.coef_[0])))
df = df.reindex(df[1].abs().sort_values().index).set_index(0)
ax = df.plot.barh(width = .6, legend = "", figsize = (12, 9))
ax.set_title("Logistic Regression Coefficients", y = 1.03, fontsize = 16.)
_ = ax.set(frame_on = False, xlabel = "", xticklabels = "", ylabel = "")

for i, label in enumerate(list(df.index)):
    score = df.loc[label][1]
    ax.annotate('%.2f' % score, (score + (-.12 if score < 0 else .02), i - .2), fontsize = 10.5)

y_pred=lr.predict(X_test)
y_test=np.array(y_test)

c=confusion_matrix(y_test,y_pred)
c

print(classification_report(y_test,y_pred))

"""## Predicting for user input data"""

arya_stark=pd.Series({'title':178,'male':0,'culture':7,'dateOfBirth':289,'house':273,'book1':0,'book2':0,'book3':0,'book4':1,'book5':1,'isAliveMother':0,'isAliveFather':0,'isAliveHeir':0,'isAliveSpouse':0,'isMarried':0,'isNoble':1,'age':18,'numDeadRelations':4,'boolDeadRelations':1,'isPopular':1,'popularity':0.7})

lr.predict_proba([arya_stark.T])

if(lr.predict_proba([arya_stark.T])[0,1]>0.5):
  print("Based on the prediction of the model Arya Stark is ALIVE")
else:
  print("Based on the prediction of the model Arya Stark is DEAD")

jon_snow=pd.Series({'title':178,'male':1,'culture':7,'dateOfBirth':289,'house':273,'book1':0,'book2':0,'book3':0,'book4':1,'book5':1,'isAliveMother':1,'isAliveFather':0,'isAliveHeir':0,'isAliveSpouse':0,'isMarried':0,'isNoble':1,'age':18,'numDeadRelations':3,'boolDeadRelations':1,'isPopular':1,'popularity':0.7})

if(lr.predict_proba([jon_snow.T])[0,1]>0.5):
  print("Based on the prediction of the model John Snow is ALIVE")
else:
  print("Based on the prediction of the model John Snow is DEAD")

tywin_lannister=pd.Series({'title':72,'male':1,'culture':0,'dateOfBirth':234,'house':145,'book1':0,'book2':0,'book3':0,'book4':1,'book5':1,'isAliveMother':0,'isAliveFather':0,'isAliveHeir':1,'isAliveSpouse':0,'isMarried':1,'isNoble':1,'age':65,'numDeadRelations':5,'boolDeadRelations':1,'isPopular':1,'popularity':0.9})

if(lr.predict_proba([tywin_lannister.T])[0,1]>0.5):
  print("Based on the prediction of the model Tywin Lannister is ALIVE")
else:
  print("Based on the prediction of the model Tywin Lannister is DEAD")